# V. 戦略的設計のための蒸留 Distillation for Strategic Design

中心的な問題に集中し、副次的な問題の海に溺れないようにするにはどうすればいいのでしょうか？

「蒸留」とは、混合物のコンポーネントを分離して、より価値のある、有用な形として本質を抽出するプロセスです。
モデルは知識の蒸留です。
より深い洞察へのリファクタリングを行うたびに、ドメインの知識や優先順位の重要な側面を抽象化していきます。
さて、戦略的な観点に一歩後退して、本章ではモデルの広い範囲を区別し、ドメインモデルを全体として蒸留する方法を見ていきます。

## コアドメイン Core Domain

大規模なシステムでは、成功のために絶対に必要だけれども複雑なサポートコンポーネントが非常に多く、ドメインモデルの本質である真のビジネス資産が不明瞭になったり、無視されたりすることがあります。

設計のすべての部分が同じように洗練されるわけではないというのは、厳しい現実です。
優先順位を設定しなければなりません。
ドメインモデルを資産にするためには、そのモデルの重要なコアを洗練されたものにし、アプリケーションの機能性を高めるべく全面的に活用しなければなりません。
しかし、希少で高度なスキルを持った開発者は、専門的なドメイン知識がなくても理解できる技術的なインフラストラクチャーや、きちんと定義可能なドメインの問題に引きずられる傾向があります。

そこで:

**モデルを分解します。**
**コアドメインを定義し、それをサポートするモデルやコードの塊から簡単に区別する手段を提供します。**
**最も価値があり特化されたコンセプトを鋭く浮き彫りにします。**
**コアは小さいものにします。**

**コアドメインに優秀な人材を適用し、それに応じた採用を行います。**
**コアドメインに労力をかけて、深いモデルを見つけ、システムのビジョンを実現するのに十分なしなやかな設計を開発します。**

他の部分への投資は、それが蒸留されたコアをどのくらいサポートするかによって調整します。


## 汎用サブドメイン Generic Subdomains

モデルのいくつかの部分は、専門的な知識を捉えたり、伝えたりすることなく、複雑さを追加してしまいます。
余計なものがあると、コアドメインを見分けたり理解したりするのが難しくなります。
モデルは、誰もが知っている一般的な原則や、主要な焦点ではないが補助的な役割を果たしている、専門分野に属する詳細に埋もれてしまいます。
しかし、どんなに一般的であっても、これらの他の要素はシステムの機能およびモデルの完全な記述にとって必要なものです。

そこで:

**プロジェクトの動機ではない凝集性のあるサブドメインを特定してください。**
**これらのサブドメインの一般的なモデルを括り出し、別のモジュールに配置してください。**
**これらのサブドメインには、元のドメインに特化されたことの痕跡を残さないようにしてください。**

**サブドメインを分離したら、継続的な開発の優先順位をコアドメインよりも低くし、コア開発者をタスクに割り当てないようにしてください（サブドメインからはドメインに関する知識がほとんど得られないからです）。**
**また、これらの一般的なサブドメインについては、市販のソリューションや公表されているモデルの導入を検討してください。**

## ドメインビジョン声明文 Domain Vision Statement

プロジェクトの最初の段階では、モデルは通常存在していませんが、その開発に集中するべきニーズはすでに存在しています。
開発の後の段階では、モデルの詳細な調査を必要にしないため、システムの価値を説明するニーズがあります。
また、ドメインモデルの重要な側面は、複数の境界づけられたコンテキストにまたがっているかもしれませんが、境界づけられたコンテキストとドメインモデルの定義上、これらの個別のモデルは、共通の焦点を示すように構造化することができません。

そこで:

**コアドメインとそれがもたらす価値、「価値提案」についての短い説明（1ページ程度）を書いてください。**
**このドメインモデルと他のモデルで変わらない面については無視してください。**
**ドメインモデルがどのように多様な利益に貢献し、釣り合うのかを示してください。**
**ただし、あくまで狭い範囲にとどめてください。**
**このステートメントは早い段階で書き、新しい洞察が得られたら修正してください。**


## 強調されたコア Highlighted Core

> ドメインビジョン声明文は、広い意味でのコアドメインを規定しますが、特定のコアモデル要素の規定は、個人の解釈の微妙さに委ねられています。チーム内で例外的に高いレベルのコミュニケーションがない限り、ビジョン・ステートメントだけではほとんど効果がありません。

チームメンバーがコアドメインの構成を大まかに理解していたとしても、異なる人が全く同じ要素を抽出することはありません。また、同じ人であっても、ある日からその翌日まで一貫していることはありません。
重要な部分を特定するためにモデルを常にフィルタリングするという精神的な労働は、設計思考に費やした方が良い集中力を消費し、モデルの包括的な知識を必要とします。
コアドメインは見やすいものでなければなりません。

コードへの大幅な構造変更は、コアドメインを識別するための理想的な方法ですが、短期的には必ずしも実用的ではありません。
実際、そのようなコードの大規模な変更は、チームが持っていないビューそのものがなければ、実施することが困難です。

そこで(強調されたコアの一つの形として):

**コアドメインとコア要素間の主要な相互作用を記述した、非常に簡潔な文書（3～7ページ）を書いてください。**

および/また(強調されたコアの別の形として):

**モデルのプライマリリポジトリー内のコアドメインの要素にフラグをつけます。その際、特にその役割を解明することはしません。**
**何がコアに含まれているか、あるいはコアから出ているかを、開発者が簡単に知ることができるようにします。**

蒸留文書がコアドメインの要点を概説している場合、モデル変更の重要性を示す実用的な指標となります。
モデルやコードの変更が蒸留文書に影響を与える場合、他のチームメンバーとの協議が必要です。
変更が行われたときには、すべてのチームメンバーに直ちに通知し、新しいバージョンの文書を普及させる必要があります。
コア以外の変更や、蒸留文書に含まれていない詳細への変更は、協議や通知なしに統合することができ、他のメンバーが作業の過程で遭遇することになります。
そうして、開発者は、ほとんどのアジャイルプロセスが提案するような完全な自律性を持つことになります。

> ビジョン声明文と強調されたコアは情報を与え、導きますが、実際にモデルやコード自体を修正するものではありません。
> 一般的なサブドメインを物理的に分割することで、いくつかの気が散る要素が取り除かれます。
> 次に、モデルや設計自体を構造的に変更して、コアドメインをより目に見えて管理しやすくするための他の方法を見てみましょう...


## 凝集されたメカニズム Cohesive Mechanisms

計算は、設計を肥大化させ始めるほどの複雑さに達することがあります。
概念的な「what」は、機械的な「how」によって押し流されてしまいます。
問題解決のためのアルゴリズムを提供するメソッドが多すぎて、問題を表現するメソッドを覆い隠してしまいます。

そこで:

**概念的にまとまりのある（凝集度の高い）メカニズムを、分離された軽量フレームワークに切り分けます。**
**特に、形式手法や、よく文書化されたアルゴリズムのカテゴリに注目してください。**
**フレームワークの機能を、意図の明白なインターフェースを用いて公開します。**
**これで、ドメインの他の要素は問題（「what」）を表現することに集中させることができる一方、解決策（「how」）の複雑さをフレームワークに委ねることができるようになります。**

**一般的なサブドメインに分割することで、乱雑さが軽減されます。また、凝集メカニズムが複雑な操作をカプセル化します。**
**これは、より焦点を絞ったモデルのみを残すようにして、ユーザーの活動に特別な価値を付加しない要素に混乱させられないようにします。**
**しかし、ドメインモデル内のコアではないすべての要素について、その良い居場所を見つけることはできそうにありません。**
**隔離されたコアは、構造的にコアドメインをマーキングするための直接的なアプローチを取ります...**


## 隔離されたコア Segregated Core

モデル内の要素には、コアドメインの役割を果たす部分もあれば、補助的な役割を果たす部分もあります。
コア要素は、一般的な要素と密接に結合されているかもしれません。
コアの概念的な結合度は強くないかもしれませんし、目に見えるものではないかもしれません。
こういったごちゃごちゃとした絡み合いすべてが、コアを窒息させてしまいます。
設計者は最も重要な関係をはっきり見ることができず、弱い設計を導いてしまいます。

そこで:

**モデルをリファクタリングして、コアの概念を（適切に定義されていないものを含めて）補助的なプレイヤーから分離し、他のコードとの結合を減らしつつ、コアの凝集度を高めます。**
**一般的な要素や補助的な要素はすべて他のオブジェクトに分解し、他のパッケージに配置します。たとえ結合度の高い要素を分離する方向でモデルをリファクタリングすることになっても、です。**


## 抽象化されたコア Abstract Core

コアドメインのモデルでさえ、通常は詳細が多く、全体像を伝えるのが難しい場合があります。

別々のモジュール内のサブドメイン間で多くの相互作用がある場合、多くの参照がモジュール間で作成されなければならず、パーティショニングの価値の多くが損なわれるか、相互作用が間接的に行われなければならず、モデルが不明瞭になってしまいます。

そこで:

**モデルの中で最も基本的な差別化概念を特定し、それらを別個のクラス、抽象クラス、またはインターフェースに切り出して分割します。**
**重要なコンポーネント間の相互作用の大部分を表現するように、この抽象モデルを設計してください。**
**この抽象的なモデル全体をそれ自身の別のモジュールに配置します。一方、具象化された詳細の実装クラスはサブドメインで定義された元のモジュールに残します。**
