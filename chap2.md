# II. モデル駆動設計のビルディングブロック Building Blocks of a Model-Driven Design

本章で紹介するパターンは、広く使われているオブジェクト指向設計のベストプラクティスを、ドメイン駆動設計に当てはめたものです。
これらのパターンは、モデルを明確にし、モデルと実装を互いに整合させ、それぞれがお互いの有効性を強化するための方針を導きます。
個々のモデル要素の詳細を慎重に作成することで、開発者はモデルを探求し、実装と密接に対応してモデルを維持するための安定したプラットフォームを得ることができます。

## レイヤー化アーキテクチャー Layered Architecture

オブジェクト指向のプログラムでは、UIやデータベース、その他の補助的コードは、しばしばビジネスオブジェクトに直接書き込まれます。
追加のビジネスロジックは、UIウィジェットやデータベーススクリプトの動作に埋め込まれています。
なぜなら、とりあえず動作させるためにはそれが一番簡単な方法だからです。

ドメインに関連したコードが他のコードの中に大量に拡散されると、コードを見つけたり挙動を推論したりすることが非常に難しくなります。
UIのちょっとした変更が、実際にはビジネスロジックを変更してしまったりします。
ビジネスルールを変更するには、UIコード、データベースコード、または他のプログラムの構成要素を綿密にトレースしなければならなくなります。
凝集度の高い、モデル駆動のオブジェクトを実装することは現実的ではなくなります。
自動テストも厄介になります。
それぞれの動作について、技術とロジック全体が関わってしまっているため、プログラムはとてもシンプルに保たれていない限り、理解できないものとなります。

そこで:

**ドメインモデルとビジネスロジックの表現を他から分離し、インフラストラクチャーやユーザーインターフェース、さらにはビジネスロジックではないアプリケーションロジックに依存しないようにします。**
**複雑なプログラムをレイヤーに分割します。**
**それぞれのレイヤーについて、下のレイヤーにのみ依存する凝集された設計を行います。**
**標準的なアーキテクチャパターンに倣って、上位のレイヤーとは疎結合にします。**
**ドメインモデルに関連するすべてのコードを1つのレイヤーに集め、ユーザーインターフェース、アプリケーション、およびインフラストラクチャのコードから分離します。**
**ドメインオブジェクトは、表示、保存、アプリケーションタスクの管理などの責務から解放され、ドメインモデルの表現に集中させるようにします。**
**これにより、モデルは、本質的なビジネス知識を獲得し、それを駆使できるほどの豊かで明確なものへと進化します。**

ここでの重要な目標は隔離(isolation)です。
「ヘキサゴナル・アーキテクチャー」などの関連パターンでも、ドメインモデルの表現が他のシステムの関心事への依存や参照を避けることを可能にする度合いにおいて、同等かそれ以上に機能するかもしれません。

## エンティティー Entities

多くのオブジェクトは、その属性が変化することはあっても、オブジェクトのライフサイクルを通じて、一貫した連続性と同一性を表しています。

オブジェクトの中には、主にその属性の値によって定義されるものではないものもあります。
これらのオブジェクトは、時を超えて、しばしば異なる表現にもまたがって同一性のつながりを表しています。
時には、そのようなオブジェクトは、属性が異なっていても、他のオブジェクトと同一視させなければならないこともあります。
ある種のオブジェクトは、他のオブジェクトが同じ属性を持っていたとしても、そのオブジェクトとは区別しなければなりません。
誤った同一性は、データの破損につながる可能性があります。

そこで:

**オブジェクトが属性ではなく、そのアイデンティティー(識別子)によって区別される場合、モデル内での定義ではアイデンティティーの方を優先します。**
**クラスの定義はシンプルにし、ライフサイクルの連続性と同一性に焦点を当てます。**

**形式や経緯に関係なく、各オブジェクトを区別する手段を定義します。**
**属性によるオブジェクトのマッチングを求める要件に注意します。**
**各オブジェクトに対して一意な結果が得られることが保証されている操作を定義し、場合によっては一意性が保証されている記号を添付します。**
**この識別手段は、外部から来たものであってもよいし、システムが作成した任意の識別子であってもよいですが、モデル内での同一性の区別に対応していなければなりません。**

**モデルは、同一であることは何を意味するのかを定義しなければなりません。**

(別名: リファレンスオブジェクト Reference Objects)

## 値オブジェクト Value Objects

何かの物の特徴を記述したり、算出したりするオブジェクトもあります。

そのようなオブジェクトは、概念的なアイデンティティーを持っていません。

エンティティーのアイデンティティーを追跡することは不可欠ですが、他のオブジェクトにアイデンティティーを付与することは、システムのパフォーマンスを悪化させたり、分析作業を追加で必要としたり、すべてのオブジェクトを同じに見せることでモデルを混乱させたりする可能性があります。
ソフトウェア設計は複雑さとの絶え間ない戦いです。
必要なところだけ特別な処理が適用されるように区別しなければなりません。

しかし、このオブジェクトのカテゴリーを単なるアイデンティティの不在と考えるのであれば、私たちのツールボックスや語彙に多くを追加したことにはなりません。
実際には、これらのオブジェクトには特有の特徴があり、モデルに対して特有の重要性を持っています。
これらは、物事を記述するオブジェクトなのです。

そこで:

**モデルの要素について、その属性とロジックだけを気にする場合は、値オブジェクトとして分類します。**
**オブジェクトが伝える属性の意味を表現し、関連する機能を与えてください。**
**値オブジェクトは不変(immutable)のものとして扱います。**
**値オブジェクトに対するすべての操作を、変化する状態に依存することのない、副作用のない関数とします。**
**値オブジェクトにはアイデンティティーを与えないことで、エンティティーを維持するために必要な設計の複雑さを回避します。**

## ドメインイベント Domain Events

ドメインエキスパートが気にする何かが発生しました。

「エンティティー」は、自身の状態と、自身のライフサイクルを統制するルールを追跡する責任があります。
しかし、状態変化の実際の原因を知らなければならない場合（これは一般的に明示されていません）、システムがどのようにして今の状態になったのかを説明するのは難しいかもしれません。
監査証跡はトレースを可能にしますが、プログラム自体のロジックには通常適していません。
エンティティーの変更履歴は、以前の状態へのアクセスを可能にしますが、それらの変更の意味を無視します。そのため、情報の操作は手続き的なものであり、しばしばドメイン層からは押し出されます。

分散システムでは、関連していながらもそれぞれ別個となる一連の問題が発生します。
分散システムにおける状態は、完全な一貫性を常に保つことはできません。
私たちは、集約を内部的には一貫性を常に保ちながら、他の変更を非同期的に行います。
ネットワークのノード間で変更が伝搬すると、複数の更新が順番を外して到着したり、別のソースから到着したりすることを解決するのが困難になることがあります。

そこで:

**ドメイン内のアクティビティに関する情報を一連の離散イベントとしてモデル化します。**
**各イベントをドメインオブジェクトとして表現します。**
**ドメインイベントは、ソフトウェア自体の活動を反映するシステムイベントそのものではありません。しかしながら、システムイベントは、ドメインイベントへの応答の一部として、またはドメインイベントに関する情報をシステムに伝達する方法として、ドメインイベントに関連付けられています。**

**ドメインイベントは、ドメイン内で発生した何かを表現するものであり、紛れもないドメインモデルの一部です。**
**ドメインの専門家が追跡したかったり知らせて欲しかったりするイベントや、他のモデルオブジェクトの状態変化に関連付けられているイベントを明示しながら、無関係なドメインアクティビティを無視します。**

分散システムでは、あるエンティティーの状態は、特定のノードで現在知られているドメインイベントから推測することができます。

ドメインイベントは、過去の何かを記録したものであるため、通常は不変です。
イベントの詳細に加えて、ドメインイベントは通常、イベントが発生した時間のタイムスタンプと、イベントに関与したエンティティーのアイデンティティーを含んでいます。
また、ドメインイベントには、イベントがシステムに入力された時刻を示す個別のタイムスタンプと、入力した人のアイデンティティーが含まれていることが多くあります。
有用な場合、ドメインイベントのアイデンティティーは、これらのプロパティをいくつか合わせたものに基づくことができます。
そのため、例えば、同じイベントの2つのインスタンスがノードに到着した場合、それらを同一のものとして認識することができます。

# サービス Services

単なる「物」ではないものもあります。

ドメインにおける概念の中には、オブジェクトとして自然にモデル化できないものがあります。
必要なドメイン機能を無理やりエンティティーや値の責務にしようとすると、モデルベースのオブジェクトの定義を歪めてしまうか、人工的で無意味なオブジェクトを追加してしまうかのいずれかになります。

そこで:

**ドメイン内の重要なプロセスや変換が、エンティティーまたは値オブジェクトの自然な責務ではない場合、サービスとして宣言された独立のインターフェースとして、その操作をモデルに追加します。**
**サービス契約（サービスとの相互作用に関するアサーションの集まり）を定義します（「表明」も参照してください）。**
**これらの表明を、特定の境界づけられたコンテキストにおけるユビキタス言語で記述します。**
**サービスに名前を付けてください。その名前もユビキタス言語の一部になります。**


## モジュール Modules

誰もがモジュールを使用していますが、モジュールをモデルの一人前の要素として扱っている人はほとんどいません。
コードは、技術的なアーキテクチャの側面から開発者の作業のアサインまで、あらゆる種類のカテゴリに落とし込まれます。
リファクタリングを多用する開発者でさえ、プロジェクトの初期段階で考えられたモジュールで満足する傾向があります。

結合（coupling）や凝集（cohesion）に関する説明は、関連付けや相互作用の分布に基づいて機械的に判断できる、技術的な指標とされる傾向があります。
しかし、モジュールに分割されるのはコードだけではありません。同時に概念も分割されます。
人が一度に考えられることの数には限界があります(故に結合度は低くするべきです)。
ばらばらに断片化された概念は、アイデアの未分化なスープと同じように理解しにくいものとなります（故に凝集度は高くするべきです）。


そこで:

**システムのストーリーを語り、まとまりのある（凝集度の高い）概念の集まりを内包したモジュールを選択します。**
**モジュールには、ユビキタス言語の一部となる名前を付けてください。**
**モジュールはモデルの一部であり、その名前はドメインへの洞察を反映したものでなければなりません。**

**多くの場合、モジュール間の結合度は低くなるはずです。結合度が高い場合、モデルを変更して概念を分離する方法を探したり、要素を意味のある方法でまとめるような、モジュールの基礎となるかもしれない、まだ見つかっていない概念を探したりします。**
**概念を独立して理解し、推論することができるような、結合度の低いものを探します。**
**モデルが高レベルのドメイン概念に従って分割され、対応するコードも同様にデカップリングされるようになるまで、モデルを改良してください。**

(別名: パッケージ Packages)


## 集約 Aggregates

複雑な関連付け（associations）を持つモデルにおいて、オブジェクトを変更する際の一貫性を保証することは困難です。
オブジェクトは自身の内部的な一貫性を維持することになっていますが、概念的には構成部分となる他のオブジェクトの変更に気づかない可能性があります。
かといって、慎重なデータベースロック方式は、複数のユーザがお互い過剰に干渉する原因となり、システムを使用不能にする可能性があります。
同様の問題は、複数のサーバ間でオブジェクトが分散される場合や、非同期トランザクションを設計する場合にも発生します。

そこで:

**エンティティーと値オブジェクトを集約にまとめて、集約ごとの境界を定義します。**
**各集約のルートとなるエンティティーを1つ選び、外部オブジェクトがルートへの参照のみを保持できるようにします（集約内のメンバーへの参照が渡された場合、単一の操作内で使用する以外では使わないようにします）。**
**集約全体に対するプロパティと不変条件（invariants）を定義し、ルートまたは指定されたフレームワーク・メカニズムに実行責任を与えます。**

トランザクションと分散を管理するために、同じ集約の境界を使用します。

集約の境界内では、整合性ルールを同期的に適用します。
境界を越える場合、更新は非同期に扱います。

1つの集約は、1つのサーバー内でまとめて管理します。
異なる集約はノード間で分散できるようにします。

これらの設計方針が集約の境界からうまく導き出せない場合は、モデルを再考してください。
ドメインシナリオが重要な新しい洞察を示唆しているでしょうか？　このような変更は、しばしばモデルの表現力と柔軟性を向上させ、トランザクションと分散の問題を解決します。

## リポジトリー Repositories

> ユビキタス言語で表現された集約への問い合わせアクセス。

何かを見つけるためだけに使われる横断的な関連付けが増殖してしまうと、モデルは混乱していきます。
成熟したモデルでは、クエリーはしばしばドメインの概念をうまく表現します。
しかし、クエリーは問題を引き起こすこともあります。

たいていのデータベースアクセス基盤を適用するための技術的な複雑さは、すぐにクライアントコードを圧迫してしまいます。そうすると、開発者はドメイン層の機能を低下させてしまい、モデルは無意味なものになってしまいます。

クエリーフレームワークがその技術的な複雑さの大部分をカプセル化することもあります。そうすると、開発者はより自動化された方法や宣言的な方法でデータベースから必要なデータを正確に取り出せるようになります。しかし、それは問題の一部を解決するにすぎません。

制約のないクエリーは、特定のフィールドをオブジェクトから引き抜いてカプセル化を破るかもしれません。あるいは、集約の内部から特定のオブジェクトをいくつかインスタンス化することで、集約のルートが無視したり、ドメインモデルのルールを適用できなくしてしまうかもしれません。
ドメインロジックはクエリーやアプリケーション層のコードに移行し、エンティティーや値オブジェクトは単なるデータコンテナになってしまいます。

そこで:

**グローバルにアクセスしたい集約について、その集約のルートとなるすべてのオブジェクトがメモリ上のコレクションであるかのように見せるサービスを作成します。**
**一般的なグローバルインターフェースを介してアクセスできるように設定します。**
**オブジェクトを追加したり削除したりするためのメソッドを提供し、データストア内での実際のデータ追加処理や削除処理をカプセル化します。**
**ドメインエキスパートにとって意味のある基準に基づいてオブジェクトを選択するメソッドを提供します。**
**完全にインスタンス化されたオブジェクトや、属性値が基準を満たすオブジェクトのコレクションを返し、実際のストレージやクエリー技術をカプセル化します。あるいは、遅延処理を利用し、完全にインスタンス化された集約であるかのような錯覚を与えるプロキシーを返します。**
**実際に直接アクセスが必要な集約ルートに対してのみ、リポジトリーを提供します。**
**アプリケーションロジックをモデルに集中させ、すべてのオブジェクトの保管とアクセスをリポジトリーに委譲します。**

## ファクトリー Factories

内部的に一貫性のある集約全体の作成や、または巨大な値オブジェクトの作成が、複雑である場合や内部構造を露出しすぎる場合、ファクトリーはカプセル化を提供します。

オブジェクトの作成はそれ自体が大きな操作になりますが、複雑な組み立て操作は、作成されたオブジェクトの責務には合いません。
その責務が合わさると、不格好で理解しにくい設計になってしまいます。
クライアントに直接構築させてしまうと、クライアントの設計を悪化させ、組み立てられるオブジェクトや集約のカプセル化を破綻させ、クライアントと作成されたオブジェクトの実装を過度に結合させてしまいます。

そこで:

**複雑なオブジェクトと集約のインスタンスを作成する責務を別のオブジェクトに移します。生成用のオブジェクト自体はドメインモデルの中では特に責務を持ちませんが、ドメイン設計の一部となるものです。**
**インスタンス化されるオブジェクトの具象クラスをクライアントが知らなくて済むような、複雑な組み立てがすべてカプセル化されたインターフェースを提供します。**
**集約の全体を一つの部品として作成し、その不変条件を強制します。**
**複雑な値オブジェクトも一つの部品として作成します。値オブジェクトの作成は、おそらくはビルダーで要素を組み立てた後になります。**
