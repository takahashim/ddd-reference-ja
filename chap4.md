# IV. 戦略的設計のためのコンテキストマッピング Context Mapping for Strategic Design

### 境界づけられたコンテキスト bounded context

その中で特定のモデルが定義され、適用される「境界」（通常はサブシステム、または特定のチームの作業）の記述。

### 上流-下流 upstream-downstream

「上流」グループの行動が「下流」グループのプロジェクトの成功に影響を与える一方で、「下流」グループの行動が「上流」グループのプロジェクトに大きく影響を与えないような、2つのグループ間の関係。
(例：2つの都市が同じ川に沿っている場合、上流の都市の汚染は主に下流の都市に影響を与えます)

上流のチームは、下流のチームの運命とは無関係に成功する可能性があります。

### 相互依存 mutually dependent

別々のコンテキストにある2つのソフトウェア開発プロジェクトが、どちらかが成功したとみなされるためには、両方ともデリバリーされなければならないという状況。
（一般的には避けたい状況ですが、2つのシステムがそれぞれ他方の情報や機能に依存している場合、当然ながらそれらを構築するプロジェクトは相互に依存していると考えられます。
しかし、システムの依存関係が一方向にしか働かない相互依存のプロジェクトもあります。
そのシステムに依存している別のシステムとの統合がなければ、システムの価値がほとんどない場合（そのシステムが唯一使われている場所だからと思われますが）、依存しているシステムを提供できないということは、両方のプロジェクトの失敗ということになります。）

### フリー free

他のコンテキストでの開発作業の方向性や成功・失敗が、デリバリーにほとんど影響を与えないソフトウェア開発コンテキストのこと。

## コンテキストマップ Context Map

> 戦略をプロットするためには、我々のプロジェクトから他の統合されるプロジェクトまでまたがるモデル開発の、現実的で大規模なビューが必要です。

グローバルな視点がない場合、個々の境界づけられたコンテクストには問題が残ってしまうこともあります。
他のモデルのコンテキストはまだ漠然としていて、流動的であるかもしれません。

他のチームの人はコンテキストの境界をあまり意識しておらず、無意識のうちに境界を曖昧にしたり、相互接続を複雑にしたりするような変更をしてしまうかもしれません。
異なるコンテクスト同士を結び付けなければならない場合、それらのコンテクストは相互に影響を与え合う傾向があります。

境界が明確であっても、他のコンテクストとの関係は、実現可能なモデルの性質や変化のペースに制約を与えます。
このような制約は、主に、それらが影響を及ぼす設計上の意思決定に関連付けるにくい、非技術的なチャネルを介して現れます。

そこで:

**プロジェクトで使用されている各モデルを特定し、その境界づけられたコンテキストを定義します。**
**これには、非オブジェクト指向のサブシステムが持つ暗黙のモデルも含まれます。**
**境界づけられたコンテキストのそれぞれに名前を付けます。その名前もユビキタス言語の一部にします。**

**コミュニケーションのための明示的な翻訳をまとめ、共有、分離メカニズム、影響力のレベルを強調することで、モデル間の接点を記述します。**

**まず既存の地形をマッピングします。**
**変形はその後で行います。**

このマップは、現実的な設計戦略の基礎となります。

関係性の特徴づけは、境界づけられたコンテクスト間の関係性の共通パターンの集合として、続くページでより具体的なものとなります。

## パートナーシップ Partnership

> 2つのコンテクストごとのチームが共に成功するか失敗する場合、しばしば協力関係が出現する。

別々のコンテキストにあるサブシステムが相互依存しており、サブシステム間の調整が不十分な場合、両方のプロジェクトのデリバリーに失敗することになります。
一方のシステムの重要な機能が失われると、もう一方のシステムがデリバリー不能になる可能性もあります。
他方のサブシステムの開発者の期待と一致しないインターフェースは、統合の失敗を招くかもしれません。
相互に合意したインターフェースが使いづらいと、クライアント側のシステムの開発を遅らせたり、実装の難しさによりサーバ側サブシステムの開発を遅らせたりする可能性があります。
失敗は、両方のプロジェクトを駄目にしてしまいます。

そこで:

**2つのコンテキストのうち、どちらかが開発に失敗すると両方のプロジェクトのデリバリーに失敗する場合は、2つのコンテキストを担当するチーム間のパートナーシップを構築します。**
**開発の協調的な計画づくりと、統合の共同管理のためのプロセスを確立します。**

**両システムの開発ニーズを満たすようインターフェースを進化させるために、両チームが協力し合わなければなりません。**
**相互に依存する機能は、同じリリースで完了するようにスケジュールを組むべきです。**

ほとんどの場合、開発者が他方のサブシステムのモデルを詳細に理解する必要はありません。しかし、プロジェクトの計画づくりを互いに調整しなければなりません。
一方のコンテキストでの開発に問題が生じた場合には、その問題を共同で検討し、どちらのコンテキストにも過度に妥協しないような迅速な設計ソリューションを見つけることが求められます。

また、統合を管理するためには、明確なプロセスが必要です。
例えば、インターフェースがクライアントシステムの期待を満たしていることを証明する特別なテストスイートを定義します。これにより、インターフェースのテストをサーバーシステムでの継続的インテグレーションの一部として実行することができるようになります。


## 共有カーネル Shared Kernel

> モデルの一部と関連するコードを共有することは、非常に親密な相互依存関係を生みます。これは設計作業に役立つこともあれば、重荷になることもあります。

機能統合が制限されている場合、大規模なコンテキストの継続的インテグレーションのためのオーバーヘッドが高すぎると判断される可能性があります。
これが特に当てはまるのは、チームに継続的インテグレーションを維持するスキルや政治的な組織がない場合、あるいは単一のチームが大きすぎて扱いにくい場合です。
そのため、境界づけられたコンテキストの分割を定義し、複数のチームを編成することになるかもしれません。

一度分離すると、密接に関連したアプリケーションに取り組みながらも連携の取れていないそれぞれのチーム内では、しばらくの間、作業を進めることはできます。しかし、各チームが作ったものをうまく統合できないかもしれません。
パートナーチームは、翻訳レイヤーやレトロフィットに多額の費用を費やしたとしても、その一方で重複した作業にコストがかかるのに加えて、共通のユビキタス言語の利点を失うことになります。

そこで:

**ドメインモデルのサブセットを他のチームと共有することにチーム内で同意し、そのサブセットを明示的な境界で指定します。**
**このカーネルは小さくなるようにしてください。**

**その部分のモデルに関連するコードやデータベース設計のサブセットは、モデルのサブセットと合わせて、この境界内に含まれます。**
**この明示的に共有されるものは特別なものとして扱います。他のチームとの協議なしに変更してはいけません。**

カーネルモデルをタイトに保ち、各チームのユビキタス言語のすり合わせを行う、継続的な統合プロセスを定義します。
機能システムの統合は、チーム内での継続的な統合のペースよりもやや少ない頻度ではあっても、頻繁に行います。


## 顧客(消費者)／供給者の開発チーム Customer/Supplier Development

> 2つのチームが上流・下流の関係にあるとき、上流のチームが下流のチームの運命から独立して成功するかもしれない一方、下流のニーズは幅広い結果を伴うさまざまな方法で対処されるようになります。

下流のチームは、上流の優先順位に翻弄されて無力になることもあります。
その間、上流のチームは下流のシステムを壊すことを心配するあまり、抑制されるかもしれません。
複雑な承認プロセスを伴う煩雑な変更要求手続きを用いても、下流チームの問題は改善されません。
そして、下流チームが変更に対する拒否権を持っている場合、上流チームの自由奔放な開発が止まってしまいます。

そこで:

**2つのチーム間で明確な顧客/供給者関係を確立し、下流の優先順位が上流の計画に反映されるようにします。**
**下流要件のためのタスクの交渉と予算化を行い、全員がコミットメントとスケジュールを理解できるようにします。**

プランニングセッションでは、アジャイルチームは、上流チームに対する顧客の役割を下流チームにさせることができます。
共同で開発された、自動化された受入テストは、上流から下流へのインターフェースが適切かを検証できます。
これらのテストを上流チームのテストスイートに追加し、継続的インテグレーションの一環として実行することで、上流チームは下流での副作用を恐れずに変更を行うことができるようになります。

## 順応者 Conformist

2つの開発チームが上流と下流の関係にあり、下流チームのニーズに応えるモチベーションが上流にない場合、下流のチームは無力です。
利他主義は上流の開発者を動機付けて約束を果たすかもしれませんが、それが果たされる可能性は低いでしょう。
そのような善意を信じることで、下流のチームが建てる計画は、決して利用できない機能に依存したものになってしまいます。
下流のプロジェクトは、チームが最終的に与えられるものだけでやっていかなければならないということを学ぶまで、遅延することになります。
下流チームのニーズに合わせたインターフェースは、配られるカードの中にはありません。

そこで:

**上流チームのモデルに忠実に従うことで、境界づけられたコンテキスト間の変換の複雑さを排除します。**
**これは下流の設計者のスタイルを圧迫し、おそらくアプリケーションの理想的なモデルは得られないでしょうが、順応性を選択することは、統合を非常に単純化します。**
**また、上流チームとユビキタス言語を共有します。**
**上流チームが運転席にいるのですから、彼らのためにコミュニケーションが容易になるのは良いことです。**
**彼らに情報を共有してもらうには、利他主義で十分かもしれません。**

## 腐敗防止層 Anticorruption Layer

> 翻訳レイヤーは、よく設計された境界づけられたコンテキスト間の橋渡しを協力的なチームと行う場合には、単純で、エレガントなものになることさえあります。しかし、コントロールやコミュニケーションが、共有カーネルやパートナー、顧客/供給者の関係を引き出すのに十分ではなかった場合、翻訳はより複雑になります。翻訳レイヤーはより防御的なトーンになります。

上流システムとの大規模なインターフェースは、最終的には下流モデルの意図を完全に圧倒し、その場しのぎの方法で他のシステムのモデルに似せて修正されることになります。
レガシーシステムのモデルは通常弱く（大きな泥団子とまではいかないにしても）、明確に設計された例外であっても、現在のプロジェクトのニーズに合わない場合があり、上流のモデルに適合することは現実的ではありません。
それでも、その統合は非常に価値があるかもしれないですし、下流のプロジェクトでは必要とされているかもしれません。

そこで:

**下流側のクライアントとして、独自のドメインモデルの観点から上流システムの機能をシステムに提供するための分離レイヤーを作成します。**
**このレイヤーは、既存のインターフェースを介して他のシステムと対話するもので、他のシステムへの変更はほとんど必要ありません。**
**内部的には、このレイヤーは2つのモデル間で、必要に応じて一方向または双方向の変換を行います。**

## 公開ホストサービス Open-host Service

> 通常、境界づけられたコンテキストそれぞれに対して、コンテキストの外部と統合する必要があるコンポーネントごとに翻訳レイヤーを定義します。統合が単発の場合は、外部システムごとに翻訳レイヤーを挿入するこのアプローチは、モデルの破損を最小限のコストで回避します。しかし、サブシステムの需要が高い場合には、より柔軟なアプローチが必要になるかもしれません。

サブシステムを他の多くのシステムと統合しなければならない場合、それぞれのトランスレーターをカスタマイズすることは、チームに負担をかけることになります。
保守するものが次第に増えると同時に、変更があったときの懸念要素も増えてきます。

そこで:

**サービスのセットとしてサブシステムへのアクセスを提供するプロトコルを定義します。**
**統合を必要とする人全員がそれを使用できるようにプロトコルをオープンにします。**
**一チーム特有のニーズがある場合を除き、新しい統合要件に対応するためにプロトコルを拡張します。**
**その後で、特殊なケースに対応するために、単発のトランスレータを使用してプロトコルを拡張し、共有プロトコルがシンプルで一貫性のあるものになるようにします。**

サービスの提供者は上流側に位置するようにします。
各クライアントは下流に位置し、一般的には順応者になるものもあれば、腐敗防止層を構築するものもあります。
公開ホストサービスを持つコンテキストは、クライアント以外のコンテキストと何らかの関係を持つかもしれません。


## 公表された言語 Published Language

> 2つの境界づけられたコンテキストにあるモデル同士の翻訳には、共通の言語が必要です。

既存のドメインモデルへの直接的な変換は、良い解決策とは言えないかもしれません。
それらのモデルは過度に複雑であったり、十分に考慮されていない場合があります。
また、おそらく文書化もなされていないでしょう。
もしそれがデータ交換言語として使用されている場合、本質的に凍結され、新たな開発ニーズに対応できません。

そこで:

**必要なドメイン情報を共通のコミュニケーション媒体として表現できる、良く文書化された共有言語を使用します。その言語へ翻訳したり、その言語から翻訳したりします。**

多くの業界では、データ交換標準の形で公表された言語を確立しています。
プロジェクトチームもまた、組織内で使用するために独自の開発を行っています。

公開された言語は、多くの場合、公開ホストサービスと組み合わされて使われます。


## 別々の道 Separate Ways

要件を定義する際には、冷酷でなければなりません。
2つの機能セットが重要な関係を持たない場合は、お互いが完全に切り離されてしまう可能性があります。

統合には常にコストがかかりますが、その割にメリットが小さいこともあります。

そこで:

**他のコンテキストとは全く関係を持たない、境界づけられたコンテキストを宣言します。開発者はこの狭いコンテキストの範囲内から、シンプルで特化された解決策を見つけることができます。**


## 巨大な泥団子 Big Ball of Mud

既存のソフトウェアシステムを調査し、定義された境界内で異なるモデルがどのように適用されているかを理解しようとすると、（多くの場合は大規模な）システムの一部では、モデルが混在していて境界が一貫していないことに気付きます。

境界が存在しないシステムにおいて、モデルのコンテキスト境界を記述しようとすると、簡単に行き詰ってしまいます。


適切に定義されたコンテキスト境界は、知的な選択と社会的な力の結果としてのみ出現します（システムを作成している人たちが、その時点でこれらの原因を意識していたとは限りませんが）。
こういった要因が存在しない場合、あるいは失われた場合には、複数の概念のシステムが互いに混在し、定義やルールが曖昧になったり、矛盾したりします。
システムは、機能が追加されるにつれて、偶発的な論理によって機能するようになります。
依存関係はソフトウェア全体に渡ります。
原因と結果の追跡は次第に困難になっていきます。
最終的には、ソフトウェアは巨大な泥団子と化してしまいます。

巨大な泥団子は、実際のところ状況によっては（FooteとYoderによる原論文で説明されているように）非常に実用的ですが、有用なモデルに必要な繊細さと精度をほぼ完全に妨げてしまいます。

そこで:

**混乱全体を取り囲むように境界を描き、それを巨大な泥団子として指定してください。**
**このコンテキストの中では高度なモデリングを適用しようとしないでください。**
**このようなシステムは、混乱が他のコンテキストにまで広がってしまう傾向があることに注意してください。**

(Brian Foote と Joseph Yoderによる http://www.laputan.org/mud/mud.html を参照)
