# VI. 戦略的設計のための大規模な構造 Large-scale Structure for Strategic Design

設計全体にまたがるパターンの中で、要素の役割を解釈できるような包括的な原則のない大規模なシステムでは、開発者は木を見て森を見ずになってしまいます。
全体の詳細を掘り下げることなしに、個々の部品が全体の中でどのような役割を果たしているのかを理解できるようにする必要があります。

「大規模構造」とは、システムを大まかなストロークで議論し、理解できるようにするための言語です。
高レベルの概念またはルール、あるいはその両方のセットは、システム全体の設計パターンを確立します。
この組織化の原則は、設計の指針となるだけでなく、理解を助けることもできます。
「様々な部品の役割がどのように全体を形作るか」という全体像の共有概念があるので、独立した作業を調整するのに役立ちます。

そこで:


**システム全体にまたがるルールや役割、関係性のパターンを考察し、全体の中での各部分の位置づけをある程度理解できるようにしますーーたとえその部分の責務を詳しい知識がなかったとしても。**


## 進化する秩序 Evolving Order

何でもありの自由な設計は、誰も全体として意味を見い出せないシステムを生み出します。そしてそれを保守するのは非常に困難です。
しかし、アーキテクチャーは、事前の仮説にもとづく設計でプロジェクトを拘束し、アプリケーションの特定の部分の開発者・設計者からあまりにも多くの力を奪ってしまいかねません。
そのうち、開発者はアプリケーションを構造に合わせて簡略化してしまうか、あるいは、アプリケーションを破壊して構造を全く持たないものにしてしまい、協調性のない開発の問題を持ち帰ってしまいます。

そこで:

**この概念的な大規模構造は、アプリケーションとともに進化していき、途中で全く異なるタイプの構造に変化する可能性があります。**
**詳細な知識を持った上で行わなければならない詳細な設計やモデルの決定を、過度に制約しないようにします。**

**大規模構造は、モデル開発に不自然な制約を強いることなく、システムを大幅に明確にする構造が見つかったタイミングで適用されるべきです。**
**不適合な構造は何も構造がないよりも悪いことです。そのため、網羅性を狙うのではなく、出てきた問題を解決する最小限の集合を見つけるのがベストです。**
**「Less is more」なのです。**

**以下に示すのは、いくつかのプロジェクトで出現した大規模構造の4つの具体的なパターンで、この種のパターンとしては代表的なものです。**


## システムのメタファー System Metaphor

ソフトウェア開発では、メタファー思考が広まっています。特にモデルを使うソフトウェア開発では顕著です。
しかし、エクストリームプログラミングでの「メタファー」のプラクティスにより、システム全体の開発に秩序をもたらすためにメタファーを使用する特定の方法を意味するようになりました。

ソフトウェアの設計は非常に抽象的で、 把握しづらい傾向があります。
開発者もユーザーも、 システムを理解し、 システム全体の見方を共有するための具体的な方法を必要としています。

そこで:

**チームメンバーの想像力をかきたて、思考を有益な方向に導くような、システムに関する具体的なアナロジーが生まれたら、それを大規模構造のメタファーとして採用します。**
**このメタファーに基づいて設計を整理し、ユビキタス言語に吸収します。**
**システムのメタファーは、システムに関するコミュニケーションを促進し、システムの開発を導くものでなければなりません。**
**これは、システムの異なる部分での一貫性を高め、潜在的には、異なる境界づけられたコンテキストをまたいだ部分でも一貫性を高めることになります。**
**しかし、すべてのメタファーは不正確なものなのです。過大な拡張や不完全さがないかどうかを継続的に再検討し、邪魔になった場合にはそれを捨てられるよう準備をしておきましょう。**


## 責務のレイヤー Responsibility Layers

オブジェクト指向設計では、個々のオブジェクトには、関連する責任の限定されたセットが割り当てられます。
責務主導設計(Responsibility-driven design)は、より大きなスケールにも適用されます。

個々のオブジェクトが手作りの責務を持っている場合、ガイドラインも統一性もなく、ドメインにおける大規模な範囲を一緒に扱う能力もありません。
大きなモデルに一貫性を与えるためには、それらの責務の割り当てに何らかの構造を課すことが有用です。

そこで:

**モデル内の概念的な依存関係、およびドメインのさまざまな部分における変化の割合と変化の発生源を見てください。**
**ドメイン内に自然な地層を見つけた場合は、それらを大まかな抽象的な責任として記述してください。**
**これらの責務は、システムの高レベルの目的と設計のストーリーを伝えるものでなければなりません。**
**モデルをリファクタリングして、各ドメインオブジェクト、集約、そしてモジュールの責務が、責務の一層の中にきちんと収まるようにします。**


## 知識レベル Knowledge Level

他のオブジェクトのグループがどのように振る舞うべきかを記述したオブジェクトのグループです。

エンティティー間の役割や関係が状況次第で変化するアプリケーションでは、複雑さが爆発的に増大する恐れがあります。
完全に汎用的なモデルも、高度にカスタマイズされたモデルも、ユーザーのニーズを満たすことはできません。
オブジェクトは、さまざまなケースをカバーするために他のタイプへの参照を持ったり、異なる状況では異なる方法で使用される属性を持ったりすることになります。
同じデータと振る舞いを持つクラスは、異なる組み立てルールに対応するためだけに増殖することがあります。

そこで:

**基本モデルの構造と動作を記述し、制約するために使用できるオブジェクトの明確なセットを作成します。**
**これらの関心事は、2つの「レベル」に分離します、1つは非常に具体的なもので、もう1つはユーザーやスーパーユーザーがカスタマイズできるルールや知識を反映したものにします。**

> (Fowler, M. 1997『アナリシスパターン―再利用可能なオブジェクトモデル』Addison-Wesleyを参照)


## 着脱可能コンポーネントのフレームワーク Pluggable Component Framework

深く蒸留され、非常に成熟したモデルに機会が生まれます。
着脱可能なコンポーネントのフレームワークは、通常、同じドメインにいくつかのアプリケーションがすでに実装されている場合にのみ使用されます。

さまざまなアプリケーションを相互運用しなければならない場合、すべて同じ抽象化に基づいていても設計が独立して行われているのであれば、複数の境界づけられたコンテキスト間の翻訳は統合を制限します。
密接に連携していないチームでは、共有カーネルは実現困難です。
重複と断片化が開発とインストールのコストを上げ、相互運用性は非常に厳しいものとなります。

そこで:

**インターフェースと相互作用の抽象化されたコアを蒸留し、インターフェースの多様な実装を自由に置き換えることができるフレームワークを作成します。**
**同様に、抽象化されたコアのインターフェースを通して厳密に動作する限り、どのアプリケーションもこれらのコンポーネントを使用できるようにします。**

