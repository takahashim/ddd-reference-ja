# III. しなやかな設計 Supple Design
プロジェクトを加速していくためには、開発が進むにつれて自身のレガシーによって鈍重さを増やしていくのではなく、一緒に仕事をしていて楽しいと思えるような、変化をもたらす設計が求められます。それが「しなやかな設計」です。

しなやかな設計は、深いモデリングを補完するものです。

開発者は2つの役割を担っています。それぞれの役割は設計によって果たされなければなりません。
同じ人が両方の役割を果たすこともあります。しかも数分で役割を切り替えることもあるかもしれません。しかし、それにもかかわらず、コードとの関係は役割によって異なります。
1つの役割はクライアントの開発者です。設計された能力を活用して、アプリケーションコードや他のドメイン層のコードにドメインオブジェクトを織り込んでいきます。
しなやかな設計は、深い潜在的モデルをあらわにし、その可能性を明確化します。
クライアントの開発者は、ドメイン内の様々なシナリオを表現するために、ゆるく結合された概念のうち、最小限の集合を柔軟に使用することができます。
設計要素は自然な形で組み合わされ、予測可能で、明確に特徴づけられた、ロバストな結果が得られます。

同じく重要なこととして、設計は、それを変更する開発者にも役立つものでなければなりません。
変更に開かれているようにするには、設計はクライアントの開発者が思い描いているはずの潜在的モデルを明らかにするような、理解しやすいものでなければなりません。
設計はドメインの深いモデルの輪郭に従わなければならないため、ほとんどの変更は、柔軟なポイントで設計を曲げることになります。
コードの効果が透過的に明らかでなければならないので、変更の結果は容易に予測できます。

* 挙動を明らかにする
* 変更コストを削減する
* それを利用するソフトウェア開発者を作る

## 意図の明白なインターフェース  Intention-Revealing Interfaces

開発者がコンポーネントを使用する際、そのコンポーネントの実装詳細を意識しなければならないのであれば、カプセル化の価値は失われています。
元の開発者以外の誰かが、オブジェクトや操作の実装に基づいてその意図を推測しなければならない場合、その新たな開発者は、操作やクラスがたまたま合っているだけの「意図」を推論してしまうかもしれません。
もしそれが本来の意図とは異なる場合、コードはとりあえず動作するかもしれませんが、設計概念の基礎が崩れてしまい、二人の開発者は当初の意図を超えた作業をすることになります。

そこで:

**クラスと操作には、その効果と意図を説明している名前をつけてください。その際、約束を実現する手段については触れないようにします。**
**これにより、クライアントの開発者は内部を理解する必要がなくなります。**
**これらの名前は、チームメンバーがすぐに意味を推測できるように、ユビキタス言語に準拠したものでなければなりません。**
**実装する前にその挙動についてのテストを書くことで、クライアント開発者モードで考えるようにしてください。**

## 副作用のない関数 Side-Effect-Free Functions

複数のルールに相互作用があったり、計算を合成したりする場合、結果を予測することが非常に困難になります。
操作を呼び出す開発者は、結果を予測するために、その実装とすべての移譲の実装を理解しなければなりません。
開発者がそのベールを破らざるを得ないのであれば、インターフェースの抽象化の有用性は限られたものとなります。
安全に予測可能な抽象化がなければ、開発者は組み合わせの爆発を制限しなければならないため、構築できる挙動の豊かさに厳しい制限を強いることになります。

そこで:

**プログラムのロジックは、可能な限り関数、つまり副作用なしに結果を返す操作として実装します。**
**コマンド（観測可能な状態への変更をもたらすメソッド）は、ドメイン情報を返さない、非常に単純な操作に厳密に分離してください。**
**責務に適した概念が思い浮かんだ場合には、複雑なロジックを値オブジェクトに移行させることで、副作用をさらに抑制します。**
**値オブジェクトのすべての操作は、副作用のない関数でなければなりません。**

## 表明 Assertions

操作がどのような副作用を起こすのかが実装による暗黙の定義でしか決められていない場合、委譲を駆使する設計は原因と結果のもつれ合いになってしまいます。
そのようなプログラムを理解する唯一の方法は、分岐パスを通して実行をトレースすることだけです。
ここではカプセル化の価値が失われています。
具体的な実行のトレースが必要なのであれば、抽象化の敗北です。

そこで:

**操作の事後条件や、クラス・集約の不変条件を記述します。**
**表明がプログラミング言語で直接コーディングできない場合は、自動化されたユニットテストを書きます。**
**プロジェクトの開発プロセスのスタイルに合った形で、ドキュメントやダイアグラムに記載します。**

開発者が意図した表明を推論できるような、凝集された概念の集合を持つモデルを探します。そうすることで、学習曲線を加速し、矛盾したコードのリスクを軽減します。

表明は、サービスとエンティティー修飾子についての契約を定義します。また、集約の不変条件も定義します。


## 独立したクラス Standalone Classes

モジュール内であっても、依存関係が追加されると、設計を解釈することが急激に難しくなります。
これは心理的な負荷を増大させ、開発者が処理できる設計の複雑さに上限を設けます。
明示的な参照よりも、暗黙の概念の方が、この負荷は大きくなります。

**オブジェクト設計の基本は、結合度を低くすることです。**
**可能であれば、徹底的にやるべきです。**
**関係のない概念はすべて図から排除します。**
**そうすれば、クラスは完全に自己完結型になり、一人でも調査・理解できるようになります。**
**このような自己完結型のクラスは、モジュールを理解する際の負担を大幅に軽減します。**


## 閉じた操作 Closure of Operations

興味深いオブジェクトは、最終的に、基本のクラスだけでは特徴づけられないようなことを行うことがほとんどです。

そこで:

**無理のない範囲で、引数の型と戻り値の型が同じになるように操作を定義してください。**
**実装クラスが状態を持ち、それを計算に使用している場合、実装クラスは実質的に演算の引数となるので、引数と戻り値は実装クラスと同じ型でなければなりません。**
**このような操作は、その型のインスタンスの集合のもとでは閉じています。**
**閉じた操作は、他の概念に依存する何かを導入することなしに、高レベルのインターフェースを提供します。**

このパターンは、値オブジェクトの操作に最もよく適用されます。
エンティティーのライフサイクルはドメインにおいて重要なものなので、質問に答えるためだけに新しいエンティティーを呼び起こしたりはできません。
とはいえ、エンティティーの型のもとで閉じられている操作もあります。
Employeeオブジェクトにその上司を尋ねると、別のEmployeeが返ってくることがあります。
しかし、一般的には、エンティティーは計算の結果になりそうな概念ではありません。
したがって、ほとんどの場合、これは値オブジェクトの中から探す機会となります。

このパターンは完全には満たされないこともあります。
引数は実装クラスと一致していても、戻り値の型が違っていたり、戻り値の型がレシーバと一致していても引数の型が違っている場合などです。
これらの操作は閉じているとは言えませんが、心理的な負担を減らすという面では、閉じていることの利点を多少得ることができます。

## 宣言的な設計 Declarative Design

手続き型のソフトウェアには、本当の意味の保証はありえません。
表明で見逃されるものを一つ挙げるとすれば、明確に除外されていない付加的な副作用をコードが持ってしまえるということがあります。
どれほどモデル駆動で設計を行ったとしても、最終的には概念的な相互作用の効果を生み出すための手続きを書くことになります。
そして、実際には何の意味も動作も新しく付け加えたりしない、ボイラープレート的なコードを書くことに多くの時間を費やしています。
意図の明白なインターフェースや、この章で紹介する他のパターンは役立ちますが、従来のオブジェクト指向プログラムに形式的な厳密さを与えることはできません。

宣言的設計が求められる背景としては、このようなことが挙げられます。
この用語はいろいろな人にいろいろな意味で捉えられていますが、一般的には、プログラムやプログラムの一部を、ある種の実行可能な仕様として作成する方法を指します。
プロパティを非常に詳細に記述することで、実際にソフトウェアを制御したりするのです。
これはリフレクション機構を介して行われるか、コンパイル時にコード生成(宣言に基づいて規定を満たすコードを自動的に生成する)を介するなど、さまざまな形で行われます。
このアプローチを使えば、別の開発者は宣言された内容を額面通りに受け取ることができます。
これは絶対的な保証です。

多くの宣言的アプローチは、開発者が意図的に、あるいは意図せずに迂回した場合に破損する可能性があります。
これは、システムが使いにくい場合や、あるいは過度に制限されている場合に発生しがちです。
宣言型プログラムの利点を得るためには、全員がフレームワークのルールに従わなければなりません。

### 設計の宣言的スタイル A Declarative Style of Design

意図の明白なインターフェース、副作用のない関数、そして表明などを利用している場合、宣言的な領域に近づいています。
宣言的設計の利点の多くは、その意味を伝える要素や、特徴的的な要素や明白な効果を持つ要素、あるいは観察可能な効果を全く持たない要素を組み合わせて持つようになってから得られます。

しなやかな設計は、クライアントコードが宣言的なスタイルの設計を使用することを可能にします。
次のセクションではその説明として、この章のパターンのいくつかをまとめて、仕様をよりしなやかで宣言的なものにします。

## 確立された形式主義を活用する Drawing on Established Formalisms

ゼロからタイトな概念フレームワークを作るというのは、日常的にできることではありません。
時には、プロジェクトに携わっている中でその一つを発見し、洗練されていくこともあります。
しかし、多くの場合、あなたのドメインや他の分野で長く確立されている概念的なシステムを使用したり、適応させたりすることができます。その中には何世紀にもわたって洗練され、蒸留されてきたものもあります。
例えば、多くのビジネスアプリケーションには会計が関係しています。
会計は、深いモデルとしなやかな設計への容易な適応を可能にする、よく発達したエンティティーとルールの集合を定義しています。

このような形式化された概念フレームワークはたくさんありますが、私の個人的なお気に入りは数学です。
基本的な算術にひねりを加えるだけで、驚くほど便利になります。
多くのドメインのどこかに数学が含まれています。
それを探して、掘り出してみてください。
専門的な数学はすっきりしていて、明確なルールで組み合わせることができ、理解するのが簡単です。

現実世界での例である「Shares Math」については、書籍『エリック・エヴァンスのドメイン駆動設計』の第8章で議論されています。

## 概念の輪郭 Conceptual Contours

時には、柔軟な組み合わせを可能にするために、機能を細かく刻む人たちがいます。
時には、複雑さをカプセル化するために大きくまとめてしまうこともあります。
時には、すべてのクラスや操作を同じような規模にして、一貫性のある粒度を求めることもあります。
これらは、一般的なルールとしてはうまく機能しない、過度に単純化したものです。
しかし、これらは基本的な問題に動機付けられています。

モデルや設計の要素がモノリシックな構造に埋め込まれていると、その機能は重複してしまいます。
外部インターフェースは、クライアントが気にするかもしれないことをすべて話すわけではありません。
異なる概念が混在しているため、その意味を理解するのは困難です。

逆に、クラスやメソッドを分解すると、クライアントを無意味に複雑にしてしまい、クライアントオブジェクトは小さなピースがどのように組み合わさっているのかを理解しなければならなくなります。
さらに悪いことに、概念が完全に失われてしまうこともあります。
ウラン原子の半分にすると、それはもうウランではありません。
もちろん、粒度の大きさだけではなく、それがどこで動作しているかも重要です。

そこで:

**設計要素（操作、インターフェース、クラス、集約）を、ドメイン内の重要な区分についての直感を考慮に入れて、まとまりのある(凝集度の高い)単位に分解します。**
**継続的なリファクタリングによる変化と安定の軸を観察し、これらの剪断パターンを説明する根本的な概念の輪郭を探してください。**
**モデルを、そもそもの知識の領域を成り立たせているドメインの一貫した側面と整合させます。**

深いモデルに基づいたしなやかな設計は、ユビキタス言語で思慮深いステートメントを作成するために論理的に組み合わされたシンプルなインターフェース群を生み出し、不適切なオプションによる心配やメンテナンスの負担を不要にします。

